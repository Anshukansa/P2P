<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P File Transfer - Local Network</title>
</head>
<body>
    <h1>P2P File Transfer - Local Network Only</h1>
    
    <div id="connection-section">
        <h2>Connection</h2>
        <button onclick="createRoom()">Create Room</button>
        <br><br>
        <input type="text" id="room-code" placeholder="Enter room code">
        <button onclick="joinRoom()">Join Room</button>
        <br><br>
        <div id="room-info"></div>
        <div id="connection-status">Disconnected</div>
    </div>

    <div id="transfer-section" style="display: none;">
        <h2>File Transfer</h2>
        <input type="file" id="file-input" multiple>
        <button onclick="sendFiles()">Send Selected Files</button>
        <br><br>
        
        <div id="transfer-progress"></div>
        <div id="speed-info"></div>
        <br>
        
        <h3>Received Files</h3>
        <div id="received-files"></div>
    </div>

    <script>
        let localConnection = null;
        let remoteConnection = null;
        let dataChannel = null;
        let currentRoomCode = null;
        let isHost = false;
        
        // File transfer variables
        let currentFile = null;
        let currentFileIndex = 0;
        let filesToSend = [];
        let receivedChunks = [];
        let expectedChunks = 0;
        let receivedChunkCount = 0;
        let fileMetadata = null;
        let transferStartTime = 0;
        let totalBytesReceived = 0;
        let totalBytesSent = 0;
        
        const CHUNK_SIZE = 16384; // 16KB chunks for optimal speed
        
        // Generate random room code
        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }
        
        // Create room
        async function createRoom() {
            currentRoomCode = generateRoomCode();
            isHost = true;
            document.getElementById('room-info').innerHTML = `Room Code: <strong>${currentRoomCode}</strong><br>Share this code with the other device`;
            await setupConnection(true);
        }
        
        // Join room
        async function joinRoom() {
            const code = document.getElementById('room-code').value.trim().toUpperCase();
            if (!code) {
                alert('Please enter a room code');
                return;
            }
            currentRoomCode = code;
            isHost = false;
            document.getElementById('room-info').innerHTML = `Joining room: <strong>${currentRoomCode}</strong>`;
            await setupConnection(false);
        }
        
        // Setup WebRTC connection
        async function setupConnection(isInitiator) {
            const config = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' }
                ]
            };
            
            localConnection = new RTCPeerConnection(config);
            
            // Handle ICE candidates
            localConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('ICE candidate:', event.candidate);
                    // In a real app, you'd send this through a signaling server
                    // For local network, we'll simulate this
                }
            };
            
            localConnection.onconnectionstatechange = () => {
                const state = localConnection.connectionState;
                document.getElementById('connection-status').textContent = `Connection: ${state}`;
                
                if (state === 'connected') {
                    document.getElementById('transfer-section').style.display = 'block';
                    document.getElementById('connection-section').style.display = 'none';
                }
            };
            
            if (isInitiator) {
                // Create data channel
                dataChannel = localConnection.createDataChannel('fileTransfer', {
                    ordered: true,
                    maxRetransmits: 3
                });
                setupDataChannel(dataChannel);
                
                // Create offer
                const offer = await localConnection.createOffer();
                await localConnection.setLocalDescription(offer);
                
                // Simulate signaling for local network
                setTimeout(() => simulateSignaling(offer, 'offer'), 1000);
            } else {
                // Handle incoming data channel
                localConnection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    setupDataChannel(dataChannel);
                };
                
                // Wait for offer (simulated)
                setTimeout(() => waitForOffer(), 1000);
            }
        }
        
        // Setup data channel handlers
        function setupDataChannel(channel) {
            channel.onopen = () => {
                console.log('Data channel opened');
                document.getElementById('connection-status').textContent = 'Connected - Ready to transfer files';
            };
            
            channel.onclose = () => {
                console.log('Data channel closed');
                document.getElementById('connection-status').textContent = 'Disconnected';
            };
            
            channel.onmessage = (event) => {
                handleMessage(event.data);
            };
            
            channel.onerror = (error) => {
                console.error('Data channel error:', error);
            };
        }
        
        // Simulate signaling for local network demo
        function simulateSignaling(data, type) {
            // Store in localStorage to simulate signaling server
            const signalData = {
                roomCode: currentRoomCode,
                type: type,
                data: data,
                timestamp: Date.now()
            };
            localStorage.setItem(`signal_${currentRoomCode}_${type}`, JSON.stringify(signalData));
        }
        
        async function waitForOffer() {
            const checkForOffer = async () => {
                const signalData = localStorage.getItem(`signal_${currentRoomCode}_offer`);
                if (signalData) {
                    const parsed = JSON.parse(signalData);
                    await localConnection.setRemoteDescription(parsed.data);
                    
                    const answer = await localConnection.createAnswer();
                    await localConnection.setLocalDescription(answer);
                    
                    simulateSignaling(answer, 'answer');
                    
                    // Check for answer on the other side
                    if (isHost) {
                        checkForAnswer();
                    }
                } else {
                    setTimeout(checkForOffer, 1000);
                }
            };
            
            const checkForAnswer = async () => {
                const signalData = localStorage.getItem(`signal_${currentRoomCode}_answer`);
                if (signalData) {
                    const parsed = JSON.parse(signalData);
                    await localConnection.setRemoteDescription(parsed.data);
                } else {
                    setTimeout(checkForAnswer, 1000);
                }
            };
            
            if (isHost) {
                checkForAnswer();
            } else {
                checkForOffer();
            }
        }
        
        // Handle incoming messages
        function handleMessage(data) {
            try {
                if (typeof data === 'string') {
                    const message = JSON.parse(data);
                    
                    if (message.type === 'file-start') {
                        startReceivingFile(message);
                    } else if (message.type === 'file-end') {
                        finishReceivingFile(message);
                    }
                } else {
                    // Binary data (file chunk)
                    receiveFileChunk(data);
                }
            } catch (error) {
                console.error('Error handling message:', error);
            }
        }
        
        // Send files
        async function sendFiles() {
            const fileInput = document.getElementById('file-input');
            const files = Array.from(fileInput.files);
            
            if (files.length === 0) {
                alert('Please select files to send');
                return;
            }
            
            if (!dataChannel || dataChannel.readyState !== 'open') {
                alert('Connection not ready');
                return;
            }
            
            filesToSend = files;
            currentFileIndex = 0;
            sendNextFile();
        }
        
        async function sendNextFile() {
            if (currentFileIndex >= filesToSend.length) {
                document.getElementById('transfer-progress').innerHTML += '<br>All files sent successfully!';
                return;
            }
            
            currentFile = filesToSend[currentFileIndex];
            const chunks = Math.ceil(currentFile.size / CHUNK_SIZE);
            
            // Send file metadata
            const metadata = {
                type: 'file-start',
                name: currentFile.name,
                size: currentFile.size,
                chunks: chunks,
                mimeType: currentFile.type
            };
            
            dataChannel.send(JSON.stringify(metadata));
            
            transferStartTime = Date.now();
            totalBytesSent = 0;
            
            document.getElementById('transfer-progress').innerHTML = 
                `Sending: ${currentFile.name} (${formatFileSize(currentFile.size)})<br>Progress: 0%`;
            
            // Send file in chunks
            const reader = new FileReader();
            let offset = 0;
            
            const sendChunk = () => {
                const chunk = currentFile.slice(offset, offset + CHUNK_SIZE);
                reader.readAsArrayBuffer(chunk);
            };
            
            reader.onload = (event) => {
                if (dataChannel.readyState === 'open') {
                    dataChannel.send(event.target.result);
                    totalBytesSent += event.target.result.byteLength;
                    
                    const progress = (totalBytesSent / currentFile.size) * 100;
                    const speed = calculateSpeed(totalBytesSent, transferStartTime);
                    
                    document.getElementById('transfer-progress').innerHTML = 
                        `Sending: ${currentFile.name} (${formatFileSize(currentFile.size)})<br>Progress: ${progress.toFixed(1)}%`;
                    document.getElementById('speed-info').innerHTML = `Speed: ${speed}`;
                    
                    offset += CHUNK_SIZE;
                    
                    if (offset < currentFile.size) {
                        setTimeout(sendChunk, 1); // Small delay to prevent overwhelming
                    } else {
                        // File sending complete
                        dataChannel.send(JSON.stringify({
                            type: 'file-end',
                            name: currentFile.name,
                            checksum: 'placeholder' // In real app, calculate actual checksum
                        }));
                        
                        currentFileIndex++;
                        setTimeout(sendNextFile, 100);
                    }
                }
            };
            
            sendChunk();
        }
        
        // Start receiving file
        function startReceivingFile(metadata) {
            fileMetadata = metadata;
            receivedChunks = [];
            expectedChunks = metadata.chunks;
            receivedChunkCount = 0;
            transferStartTime = Date.now();
            totalBytesReceived = 0;
            
            document.getElementById('transfer-progress').innerHTML = 
                `Receiving: ${metadata.name} (${formatFileSize(metadata.size)})<br>Progress: 0%`;
        }
        
        // Receive file chunk
        function receiveFileChunk(chunk) {
            receivedChunks.push(chunk);
            receivedChunkCount++;
            totalBytesReceived += chunk.byteLength;
            
            const progress = (receivedChunkCount / expectedChunks) * 100;
            const speed = calculateSpeed(totalBytesReceived, transferStartTime);
            
            document.getElementById('transfer-progress').innerHTML = 
                `Receiving: ${fileMetadata.name} (${formatFileSize(fileMetadata.size)})<br>Progress: ${progress.toFixed(1)}%`;
            document.getElementById('speed-info').innerHTML = `Speed: ${speed}`;
        }
        
        // Finish receiving file
        function finishReceivingFile(endMessage) {
            const blob = new Blob(receivedChunks, { type: fileMetadata.mimeType });
            
            // Create download link
            const url = URL.createObjectURL(blob);
            const downloadDiv = document.createElement('div');
            downloadDiv.innerHTML = `
                <strong>${fileMetadata.name}</strong> (${formatFileSize(fileMetadata.size)}) - 
                <a href="${url}" download="${fileMetadata.name}">Download</a>
                <br>
            `;
            
            document.getElementById('received-files').appendChild(downloadDiv);
            document.getElementById('transfer-progress').innerHTML += '<br>File received successfully!';
        }
        
        // Calculate transfer speed
        function calculateSpeed(bytes, startTime) {
            const elapsed = (Date.now() - startTime) / 1000; // seconds
            const speed = bytes / elapsed; // bytes per second
            return formatFileSize(speed) + '/s';
        }
        
        // Format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (currentRoomCode) {
                localStorage.removeItem(`signal_${currentRoomCode}_offer`);
                localStorage.removeItem(`signal_${currentRoomCode}_answer`);
            }
        });
    </script>
</body>
</html>
