<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local Network Transfer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 15px;
        }
        
        .container {
            max-width: 500px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 25px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
        }
        
        .main {
            padding: 25px;
        }
        
        .device-section {
            text-align: center;
            margin-bottom: 25px;
        }
        
        .device-circle {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: #4CAF50;
            margin: 15px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .device-circle:hover {
            transform: scale(1.05);
        }
        
        .device-circle.waiting {
            background: #2196F3;
            animation: pulse 2s infinite;
        }
        
        .device-circle.connected {
            background: #4CAF50;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .connection-code {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: center;
            font-family: monospace;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
            color: #333;
        }
        
        .btn {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-primary {
            background: #2196F3;
            color: white;
        }
        
        .btn-success {
            background: #4CAF50;
            color: white;
        }
        
        .btn-danger {
            background: #f44336;
            color: white;
        }
        
        .btn-download {
            background: #FF9800;
            color: white;
            margin: 10px 0;
        }
        
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .input-field {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
        }
        
        .input-field:focus {
            outline: none;
            border-color: #2196F3;
        }
        
        .file-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            margin: 15px 0;
            transition: all 0.3s ease;
        }
        
        .file-area.drag-over {
            border-color: #2196F3;
            background: rgba(33, 150, 243, 0.1);
        }
        
        .file-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #2196F3;
        }
        
        .file-name {
            font-weight: bold;
            margin-bottom: 5px;
            word-break: break-all;
        }
        
        .file-size {
            color: #666;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .progress-container {
            margin: 10px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: #4CAF50;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .progress-text {
            font-size: 12px;
            color: #666;
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
        }
        
        .speed-info {
            font-size: 11px;
            color: #999;
            text-align: center;
            margin: 5px 0;
        }
        
        .status-message {
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
        }
        
        .status-success {
            background: #e8f5e8;
            color: #2e7d32;
            border: 1px solid #c8e6c9;
        }
        
        .status-error {
            background: #ffebee;
            color: #c62828;
            border: 1px solid #ffcdd2;
        }
        
        .status-info {
            background: #e3f2fd;
            color: #1976d2;
            border: 1px solid #bbdefb;
        }
        
        .hidden {
            display: none;
        }
        
        .download-item {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #4CAF50;
        }
        
        .local-network-indicator {
            background: #fff3e0;
            color: #ef6c00;
            padding: 8px;
            border-radius: 5px;
            margin: 5px 0;
            font-size: 11px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè† Local Network Transfer</h1>
            <p>VLC-style high-speed local transfer</p>
        </div>
        
        <div class="main">
            <!-- Device Status -->
            <div class="device-section">
                <div id="status-text">Ready to start</div>
                <div id="device-circle" class="device-circle" onclick="startHost()">
                    <span id="device-text">START</span>
                </div>
                
                <!-- Connection Code -->
                <div id="code-section" class="hidden">
                    <div>Share this code:</div>
                    <div id="connection-code" class="connection-code">------</div>
                </div>
            </div>
            
            <!-- Messages -->
            <div id="messages"></div>
            
            <!-- File Selection -->
            <input type="file" id="file-input" multiple style="display: none;">
            <button class="btn btn-primary" onclick="selectFiles()" id="send-btn" disabled>
                üì§ Select Files to Send
            </button>
            
            <!-- Drag Drop -->
            <div class="file-area" id="drop-area">
                <p>üìé Drop files here or click above</p>
            </div>
            
            <!-- Sending Files -->
            <div id="sending-files"></div>
            
            <!-- Connection -->
            <input type="text" id="peer-code" placeholder="Enter code from other device" class="input-field">
            <button class="btn btn-success" onclick="connectToPeer()" id="connect-btn">
                üîó Connect
            </button>
            
            <!-- Received Files -->
            <div id="received-files"></div>
            
            <!-- Disconnect -->
            <button class="btn btn-danger hidden" onclick="disconnect()" id="disconnect-btn">
                ‚ùå Disconnect
            </button>
        </div>
    </div>

    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script>
        class LocalNetworkTransfer {
            constructor() {
                this.peer = null;
                this.connection = null;
                this.connectionCode = '';
                this.isConnected = false;
                
                // File transfer state
                this.sendingFiles = new Map();
                this.receivingFiles = new Map();
                
                // Local network optimized settings
                this.chunkSize = 1024 * 1024; // 1MB chunks for local network speed
                this.windowSize = 10; // 10 chunks in parallel for local network
                this.ackTimeout = 1000; // 1 second timeout for local network
                this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                
                // iOS-specific settings to prevent crashes
                if (this.isIOS) {
                    this.chunkSize = 512 * 1024; // 512KB for iOS to prevent memory issues
                    this.windowSize = 5; // Fewer parallel chunks for iOS
                    this.memoryOptimization = true;
                }
                
                this.init();
            }
            
            init() {
                this.setupDragDrop();
                this.setupFileInput();
                this.preventIOSRefresh();
                this.log('Local network transfer system initialized');
            }
            
            log(message) {
                console.log('[LocalTransfer]', message);
            }
            
            // Prevent iOS Safari auto-refresh issues
            preventIOSRefresh() {
                if (this.isIOS) {
                    // Prevent memory warnings that cause refresh
                    window.addEventListener('beforeunload', (e) => {
                        if (this.hasActiveTransfers()) {
                            e.preventDefault();
                            e.returnValue = 'File transfer in progress';
                            return 'File transfer in progress';
                        }
                    });
                    
                    // Memory management for iOS
                    window.addEventListener('pagehide', () => {
                        this.cleanupMemory();
                    });
                    
                    // Prevent iOS bounce/refresh gestures during transfer
                    document.addEventListener('touchmove', (e) => {
                        if (this.hasActiveTransfers()) {
                            e.preventDefault();
                        }
                    }, { passive: false });
                }
            }
            
            hasActiveTransfers() {
                return this.sendingFiles.size > 0 || this.receivingFiles.size > 0;
            }
            
            cleanupMemory() {
                // Force garbage collection for iOS
                this.sendingFiles.clear();
                this.receivingFiles.clear();
            }
            
            setupDragDrop() {
                const dropArea = document.getElementById('drop-area');
                
                dropArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropArea.classList.add('drag-over');
                });
                
                dropArea.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    dropArea.classList.remove('drag-over');
                });
                
                dropArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropArea.classList.remove('drag-over');
                    this.handleFiles(e.dataTransfer.files);
                });
            }
            
            setupFileInput() {
                document.getElementById('file-input').addEventListener('change', (e) => {
                    this.handleFiles(e.target.files);
                });
            }
            
            generateCode() {
                return Math.random().toString(36).substring(2, 8).toUpperCase();
            }
            
            async startHost() {
                try {
                    this.connectionCode = this.generateCode();
                    this.showMessage('Starting local network connection...', 'info');
                    
                    // Local network optimized configuration
                    this.peer = new Peer(this.connectionCode, {
                        debug: 0,
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' }
                            ],
                            // Optimized for local network
                            iceCandidatePoolSize: 10,
                            iceTransportPolicy: 'all'
                        }
                    });
                    
                    this.peer.on('open', (id) => {
                        this.log(`Local host started: ${id}`);
                        this.updateStatus('Waiting for local connection...', 'waiting');
                        this.showConnectionCode();
                        this.showMessage('Share code with device on same network', 'info');
                    });
                    
                    this.peer.on('connection', (conn) => {
                        this.log('Local device connected');
                        this.connection = conn;
                        this.setupLocalConnection();
                    });
                    
                    this.peer.on('error', (err) => {
                        this.log(`Peer error: ${err}`);
                        this.showMessage('Connection failed. Try again.', 'error');
                        this.resetConnection();
                    });
                    
                } catch (error) {
                    this.log(`Start error: ${error}`);
                    this.showMessage('Failed to start. Try again.', 'error');
                }
            }
            
            async connectToPeer() {
                const code = document.getElementById('peer-code').value.trim().toUpperCase();
                if (!code) {
                    this.showMessage('Please enter a code', 'error');
                    return;
                }
                
                try {
                    this.showMessage('Connecting to local network...', 'info');
                    
                    this.peer = new Peer({
                        debug: 0,
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' }
                            ],
                            iceCandidatePoolSize: 10,
                            iceTransportPolicy: 'all'
                        }
                    });
                    
                    this.peer.on('open', () => {
                        this.log('Connecting to local peer');
                        this.connection = this.peer.connect(code, {
                            reliable: true,
                            serialization: 'binary'
                        });
                        this.setupLocalConnection();
                        this.updateStatus('Connecting...', 'waiting');
                    });
                    
                    this.peer.on('error', (err) => {
                        this.log(`Connect error: ${err}`);
                        this.showMessage('Failed to connect. Check code.', 'error');
                        this.resetConnection();
                    });
                    
                } catch (error) {
                    this.log(`Connect error: ${error}`);
                    this.showMessage('Connection failed. Try again.', 'error');
                }
            }
            
            setupLocalConnection() {
                if (!this.connection) return;
                
                this.connection.on('open', () => {
                    this.log('Local network connection established');
                    this.isConnected = true;
                    this.updateStatus('Connected!', 'connected');
                    this.showMessage('üè† Local network ready for high-speed transfer!', 'success');
                    this.enableFileSharing();
                });
                
                this.connection.on('data', (data) => {
                    this.handleLocalData(data);
                });
                
                this.connection.on('close', () => {
                    this.log('Local connection closed');
                    this.showMessage('Connection closed', 'error');
                    this.resetConnection();
                });
                
                this.connection.on('error', (err) => {
                    this.log(`Connection error: ${err}`);
                    this.showMessage('Connection error', 'error');
                    this.resetConnection();
                });
            }
            
            showConnectionCode() {
                document.getElementById('connection-code').textContent = this.connectionCode;
                document.getElementById('code-section').classList.remove('hidden');
            }
            
            updateStatus(message, state) {
                document.getElementById('status-text').textContent = message;
                const circle = document.getElementById('device-circle');
                const text = document.getElementById('device-text');
                
                circle.className = 'device-circle';
                if (state) circle.classList.add(state);
                
                switch (state) {
                    case 'waiting':
                        text.textContent = 'WAITING';
                        break;
                    case 'connected':
                        text.textContent = 'CONNECTED';
                        break;
                    default:
                        text.textContent = 'START';
                }
            }
            
            enableFileSharing() {
                document.getElementById('send-btn').disabled = false;
                document.getElementById('connect-btn').classList.add('hidden');
                document.getElementById('disconnect-btn').classList.remove('hidden');
            }
            
            handleFiles(files) {
                if (!this.isConnected) {
                    this.showMessage('Please connect first', 'error');
                    return;
                }
                
                Array.from(files).forEach((file, index) => {
                    this.sendFileLocal(file, `file_${Date.now()}_${index}`);
                });
            }
            
            async sendFileLocal(file, fileId) {
                this.log(`Starting local network send: ${file.name}`);
                
                const totalChunks = Math.ceil(file.size / this.chunkSize);
                
                const fileState = {
                    file: file,
                    fileId: fileId,
                    totalChunks: totalChunks,
                    sentChunks: 0,
                    ackedChunks: new Set(),
                    startTime: Date.now(),
                    inFlight: new Set(),
                    nextChunk: 0
                };
                
                this.sendingFiles.set(fileId, fileState);
                this.showSendingFile(fileState);
                
                // Send file metadata
                this.sendData({
                    type: 'file-start',
                    fileId: fileId,
                    name: file.name,
                    size: file.size,
                    totalChunks: totalChunks,
                    chunkSize: this.chunkSize
                });
                
                // Start local network streaming
                this.streamFileLocal(fileId);
            }
            
            async streamFileLocal(fileId) {
                const fileState = this.sendingFiles.get(fileId);
                if (!fileState) return;
                
                // Fill the window with chunks
                while (fileState.inFlight.size < this.windowSize && fileState.nextChunk < fileState.totalChunks) {
                    if (!fileState.ackedChunks.has(fileState.nextChunk)) {
                        this.sendChunkLocal(fileId, fileState.nextChunk);
                    }
                    fileState.nextChunk++;
                }
                
                // Check completion
                if (fileState.ackedChunks.size === fileState.totalChunks) {
                    this.completeLocalSend(fileId);
                }
            }
            
            async sendChunkLocal(fileId, chunkIndex) {
                const fileState = this.sendingFiles.get(fileId);
                if (!fileState) return;
                
                try {
                    const start = chunkIndex * this.chunkSize;
                    const end = Math.min(start + this.chunkSize, fileState.file.size);
                    const chunk = fileState.file.slice(start, end);
                    
                    let arrayBuffer;
                    if (this.isIOS) {
                        // iOS-safe chunk reading
                        arrayBuffer = await this.readChunkSafely(chunk);
                    } else {
                        arrayBuffer = await chunk.arrayBuffer();
                    }
                    
                    fileState.inFlight.add(chunkIndex);
                    
                    this.sendData({
                        type: 'file-chunk',
                        fileId: fileId,
                        chunkIndex: chunkIndex,
                        data: arrayBuffer
                    });
                    
                    this.updateSendProgress(fileId);
                    
                    // Local network timeout
                    setTimeout(() => {
                        if (!fileState.ackedChunks.has(chunkIndex)) {
                            fileState.inFlight.delete(chunkIndex);
                            this.streamFileLocal(fileId);
                        }
                    }, this.ackTimeout);
                    
                } catch (error) {
                    this.log(`Error sending chunk ${chunkIndex}: ${error}`);
                    fileState.inFlight.delete(chunkIndex);
                }
            }
            
            // iOS-safe chunk reading
            async readChunkSafely(chunk) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = () => reject(reader.error);
                    reader.readAsArrayBuffer(chunk);
                });
            }
            
            sendData(data) {
                if (this.connection && this.isConnected) {
                    try {
                        this.connection.send(data);
                    } catch (error) {
                        this.log(`Send error: ${error}`);
                    }
                }
            }
            
            handleLocalData(data) {
                switch (data.type) {
                    case 'file-start':
                        this.handleFileStart(data);
                        break;
                    case 'file-chunk':
                        this.handleFileChunk(data);
                        break;
                    case 'chunk-ack':
                        this.handleChunkAck(data);
                        break;
                }
            }
            
            handleFileStart(data) {
                this.log(`Receiving file: ${data.name}`);
                
                const fileState = {
                    name: data.name,
                    size: data.size,
                    fileId: data.fileId,
                    totalChunks: data.totalChunks,
                    chunkSize: data.chunkSize,
                    chunks: new Array(data.totalChunks),
                    receivedChunks: new Set(),
                    startTime: Date.now()
                };
                
                this.receivingFiles.set(data.fileId, fileState);
                this.showReceivingFile(fileState);
            }
            
            handleFileChunk(data) {
                const fileState = this.receivingFiles.get(data.fileId);
                if (!fileState) return;
                
                // Store chunk with iOS memory management
                if (this.isIOS && this.memoryOptimization) {
                    // For iOS, immediately acknowledge and don't keep all chunks in memory
                    this.sendData({
                        type: 'chunk-ack',
                        fileId: data.fileId,
                        chunkIndex: data.chunkIndex
                    });
                    
                    // Store chunk temporarily
                    fileState.chunks[data.chunkIndex] = new Uint8Array(data.data);
                    fileState.receivedChunks.add(data.chunkIndex);
                    
                    this.updateReceiveProgress(data.fileId);
                    
                    // Check if complete and assemble immediately
                    if (fileState.receivedChunks.size === fileState.totalChunks) {
                        setTimeout(() => this.assembleFileLocal(data.fileId), 100);
                    }
                } else {
                    // Standard handling for non-iOS
                    fileState.chunks[data.chunkIndex] = new Uint8Array(data.data);
                    fileState.receivedChunks.add(data.chunkIndex);
                    
                    this.sendData({
                        type: 'chunk-ack',
                        fileId: data.fileId,
                        chunkIndex: data.chunkIndex
                    });
                    
                    this.updateReceiveProgress(data.fileId);
                    
                    if (fileState.receivedChunks.size === fileState.totalChunks) {
                        this.assembleFileLocal(data.fileId);
                    }
                }
            }
            
            handleChunkAck(data) {
                const fileState = this.sendingFiles.get(data.fileId);
                if (!fileState) return;
                
                fileState.ackedChunks.add(data.chunkIndex);
                fileState.inFlight.delete(data.chunkIndex);
                
                this.updateSendProgress(data.fileId);
                this.streamFileLocal(data.fileId);
            }
            
            completeLocalSend(fileId) {
                const fileState = this.sendingFiles.get(fileId);
                if (!fileState) return;
                
                const duration = (Date.now() - fileState.startTime) / 1000;
                const speed = (fileState.file.size / duration / 1024 / 1024).toFixed(1);
                
                this.log(`Local transfer complete: ${fileState.file.name} at ${speed} MB/s`);
                
                const fileDiv = document.getElementById(`sending-${fileId}`);
                if (fileDiv) {
                    fileDiv.querySelector('.progress-text').innerHTML = `<span>‚úÖ Sent at ${speed} MB/s!</span>`;
                    fileDiv.querySelector('.local-network-indicator').textContent = `‚úÖ Local network transfer complete - ${speed} MB/s`;
                }
                
                this.sendingFiles.delete(fileId);
                this.showMessage(`‚úÖ ${fileState.file.name} sent at ${speed} MB/s!`, 'success');
            }
            
            assembleFileLocal(fileId) {
                const fileState = this.receivingFiles.get(fileId);
                if (!fileState) return;
                
                this.log(`Assembling local file: ${fileState.name}`);
                
                try {
                    // Calculate total size
                    let totalSize = 0;
                    fileState.chunks.forEach(chunk => {
                        if (chunk) totalSize += chunk.length;
                    });
                    
                    // Assemble file
                    const assembled = new Uint8Array(totalSize);
                    let offset = 0;
                    
                    fileState.chunks.forEach(chunk => {
                        if (chunk) {
                            assembled.set(chunk, offset);
                            offset += chunk.length;
                        }
                    });
                    
                    // Create blob
                    const blob = new Blob([assembled]);
                    fileState.blob = blob;
                    
                    const duration = (Date.now() - fileState.startTime) / 1000;
                    const speed = (fileState.size / duration / 1024 / 1024).toFixed(1);
                    
                    this.log(`Local file assembled: ${fileState.name} at ${speed} MB/s`);
                    
                    // Clear chunks from memory immediately for iOS
                    if (this.isIOS) {
                        fileState.chunks = null;
                    }
                    
                    // Update UI
                    const fileDiv = document.getElementById(`receiving-${fileId}`);
                    fileDiv.className = 'download-item';
                    fileDiv.innerHTML = `
                        <div class="file-name">‚úÖ ${fileState.name}</div>
                        <div class="file-size">${this.formatFileSize(blob.size)}</div>
                        <div class="local-network-indicator">‚úÖ Local network transfer complete - ${speed} MB/s</div>
                        <button class="btn btn-download" onclick="app.downloadFile('${fileId}')">
                            üíæ Download File
                        </button>
                    `;
                    
                    this.showMessage(`‚úÖ ${fileState.name} ready at ${speed} MB/s!`, 'success');
                    
                } catch (error) {
                    this.log(`Assembly error: ${error}`);
                    this.showMessage(`Error receiving ${fileState.name}`, 'error');
                }
            }
            
            showSendingFile(fileState) {
                const container = document.getElementById('sending-files');
                const fileDiv = document.createElement('div');
                fileDiv.className = 'file-item';
                fileDiv.id = `sending-${fileState.fileId}`;
                fileDiv.innerHTML = `
                    <div class="file-name">${fileState.file.name}</div>
                    <div class="file-size">${this.formatFileSize(fileState.file.size)}</div>
                    <div class="local-network-indicator">üè† Local network transfer with ${this.chunkSize/1024}KB chunks</div>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" id="send-progress-${fileState.fileId}"></div>
                        </div>
                        <div class="progress-text" id="send-text-${fileState.fileId}">
                            <span>Starting...</span>
                        </div>
                        <div class="speed-info" id="send-speed-${fileState.fileId}">
                            0/${fileState.totalChunks} chunks sent
                        </div>
                    </div>
                `;
                container.appendChild(fileDiv);
            }
            
            showReceivingFile(fileState) {
                const container = document.getElementById('received-files');
                const fileDiv = document.createElement('div');
                fileDiv.className = 'file-item';
                fileDiv.id = `receiving-${fileState.fileId}`;
                fileDiv.innerHTML = `
                    <div class="file-name">üì• ${fileState.name}</div>
                    <div class="file-size">${this.formatFileSize(fileState.size)}</div>
                    <div class="local-network-indicator">üè† Receiving via local network</div>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" id="receive-progress-${fileState.fileId}"></div>
                        </div>
                        <div class="progress-text" id="receive-text-${fileState.fileId}">
                            <span>Receiving...</span>
                        </div>
                        <div class="speed-info" id="receive-speed-${fileState.fileId}">
                            0/${fileState.totalChunks} chunks received
                        </div>
                    </div>
                `;
                container.appendChild(fileDiv);
                
                this.showMessage(`üì• Receiving ${fileState.name} via local network...`, 'info');
            }
            
            updateSendProgress(fileId) {
                const fileState = this.sendingFiles.get(fileId);
                if (!fileState) return;
                
                const progress = (fileState.ackedChunks.size / fileState.totalChunks) * 100;
                const progressBar = document.getElementById(`send-progress-${fileId}`);
                const progressText = document.getElementById(`send-text-${fileId}`);
                const speedInfo = document.getElementById(`send-speed-${fileId}`);
                
                if (progressBar) progressBar.style.width = `${progress}%`;
                if (progressText) progressText.innerHTML = `<span>${Math.round(progress)}%</span>`;
                if (speedInfo) speedInfo.textContent = `${fileState.ackedChunks.size}/${fileState.totalChunks} chunks confirmed`;
            }
            
            updateReceiveProgress(fileId) {
                const fileState = this.receivingFiles.get(fileId);
                if (!fileState) return;
                
                const progress = (fileState.receivedChunks.size / fileState.totalChunks) * 100;
                const progressBar = document.getElementById(`receive-progress-${fileId}`);
                const progressText = document.getElementById(`receive-text-${fileId}`);
                const speedInfo = document.getElementById(`receive-speed-${fileId}`);
                
                if (progressBar) progressBar.style.width = `${progress}%`;
                if (progressText) progressText.innerHTML = `<span>${Math.round(progress)}%</span>`;
                if (speedInfo) speedInfo.textContent = `${fileState.receivedChunks.size}/${fileState.totalChunks} chunks received`;
            }
            
            downloadFile(fileId) {
                const fileState = this.receivingFiles.get(fileId);
                if (!fileState || !fileState.blob) {
                    this.showMessage('File not available', 'error');
                    return;
                }
                
                try {
                    if (this.isIOS && navigator.share) {
                        const file = new File([fileState.blob], fileState.name);
                        navigator.share({
                            files: [file],
                            title: fileState.name
                        }).then(() => {
                            this.showMessage(`Shared: ${fileState.name}`, 'success');
                        }).catch(err => {
                            this.log(`Share failed: ${err}`);
                            this.regularDownload(fileState.blob, fileState.name);
                        });
                    } else {
                        this.regularDownload(fileState.blob, fileState.name);
                    }
                    
                } catch (error) {
                    this.log(`Download error: ${error}`);
                    this.showMessage('Download failed', 'error');
                }
            }
            
            regularDownload(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.style.display = 'none';
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                setTimeout(() => URL.revokeObjectURL(url), 1000);
                
                this.showMessage(`Downloaded: ${filename}`, 'success');
                this.log(`Download completed: ${filename}`);
            }
            
            disconnect() {
                if (this.connection) this.connection.close();
                if (this.peer) this.peer.destroy();
                this.resetConnection();
                this.showMessage('Disconnected', 'info');
            }
            
            resetConnection() {
                this.peer = null;
                this.connection = null;
                this.isConnected = false;
                this.connectionCode = '';
                this.cleanupMemory();
                
                this.updateStatus('Ready to start', '');
                document.getElementById('code-section').classList.add('hidden');
                document.getElementById('send-btn').disabled = true;
                document.getElementById('connect-btn').classList.remove('hidden');
                document.getElementById('disconnect-btn').classList.add('hidden');
                document.getElementById('sending-files').innerHTML = '';
                document.getElementById('received-files').innerHTML = '';
            }
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            showMessage(message, type) {
                const container = document.getElementById('messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = `status-message status-${type}`;
                messageDiv.textContent = message;
                
                container.innerHTML = '';
                container.appendChild(messageDiv);
                
                setTimeout(() => {
                    if (container.contains(messageDiv)) {
                        container.removeChild(messageDiv);
                    }
                }, 4000);
            }
        }
        
        // Initialize app
        const app = new LocalNetworkTransfer();
        
        // Global functions
        function startHost() {
            const deviceText = document.getElementById('device-text');
            if (deviceText.textContent === 'START') {
                app.startHost();
            }
        }
        
        function selectFiles() {
            document.getElementById('file-input').click();
        }
        
        function connectToPeer() {
            app.connectToPeer();
        }
        
        function disconnect() {
            app.disconnect();
        }
    </script>
</body>
</html>
