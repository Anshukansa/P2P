<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P File Transfer - Local Network</title>
</head>
<body>
    <h1>P2P File Transfer - Local Network</h1>
    
    <div id="device-info">
        <h2>Your Device</h2>
        <div>Device ID: <strong id="my-device-id"></strong></div>
        <div>Status: <span id="my-status">Starting...</span></div>
    </div>

    <div id="available-devices">
        <h2>Available Devices</h2>
        <div id="device-list">Scanning for devices...</div>
        <button onclick="refreshDevices()">Refresh Devices</button>
    </div>

    <div id="connection-status" style="display: none;">
        <h2>Connection Status</h2>
        <div id="connection-info"></div>
    </div>

    <div id="file-transfer" style="display: none;">
        <h2>Send Files</h2>
        <input type="file" id="file-input" multiple>
        <button onclick="sendFiles()">Send Selected Files</button>
        
        <div id="transfer-progress"></div>
        <div id="speed-info"></div>
    </div>

    <div id="received-files">
        <h2>Received Files</h2>
        <div id="file-list"></div>
    </div>

    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script>
        let peer = null;
        let connections = new Map();
        let myDeviceId = null;
        let transferStartTime = 0;
        let totalBytes = 0;
        let isTransferring = false;

        const CHUNK_SIZE = 16384; // 16KB chunks
        const DISCOVERY_KEY = 'p2p_devices';
        const DEVICE_TIMEOUT = 30000; // 30 seconds

        // Initialize
        function init() {
            myDeviceId = generateDeviceId();
            document.getElementById('my-device-id').textContent = myDeviceId;
            
            // Initialize PeerJS
            peer = new Peer(myDeviceId, {
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                }
            });

            peer.on('open', function(id) {
                console.log('Peer opened with ID:', id);
                document.getElementById('my-status').textContent = 'Online';
                announceDevice();
                startDeviceDiscovery();
            });

            peer.on('connection', function(conn) {
                console.log('Incoming connection from:', conn.peer);
                setupConnection(conn);
                updateConnectionStatus();
            });

            peer.on('error', function(err) {
                console.error('Peer error:', err);
                document.getElementById('my-status').textContent = 'Error: ' + err.message;
            });

            // Start periodic device announcement
            setInterval(announceDevice, 5000);
            
            // Start periodic device discovery
            setInterval(discoverDevices, 3000);
        }

        function generateDeviceId() {
            const adjectives = ['Red', 'Blue', 'Green', 'Yellow', 'Purple', 'Orange', 'Pink', 'Cyan'];
            const nouns = ['Phone', 'Laptop', 'Tablet', 'Desktop', 'Device', 'Computer', 'Mobile', 'PC'];
            const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
            const noun = nouns[Math.floor(Math.random() * nouns.length)];
            const num = Math.floor(Math.random() * 999);
            return `${adj}${noun}${num}`;
        }

        function announceDevice() {
            if (!peer || !peer.id) return;
            
            const devices = getStoredDevices();
            devices[myDeviceId] = {
                id: myDeviceId,
                timestamp: Date.now(),
                userAgent: navigator.userAgent.substring(0, 50)
            };
            
            localStorage.setItem(DISCOVERY_KEY, JSON.stringify(devices));
        }

        function getStoredDevices() {
            try {
                const stored = localStorage.getItem(DISCOVERY_KEY);
                return stored ? JSON.parse(stored) : {};
            } catch (e) {
                return {};
            }
        }

        function cleanupOldDevices(devices) {
            const now = Date.now();
            const cleaned = {};
            
            for (const [id, device] of Object.entries(devices)) {
                if (now - device.timestamp < DEVICE_TIMEOUT) {
                    cleaned[id] = device;
                }
            }
            
            return cleaned;
        }

        function discoverDevices() {
            const devices = cleanupOldDevices(getStoredDevices());
            localStorage.setItem(DISCOVERY_KEY, JSON.stringify(devices));
            
            const deviceListDiv = document.getElementById('device-list');
            const availableDevices = Object.values(devices).filter(d => d.id !== myDeviceId);
            
            if (availableDevices.length === 0) {
                deviceListDiv.innerHTML = 'No other devices found. Make sure other devices have this page open.';
                return;
            }

            let html = '';
            availableDevices.forEach(device => {
                const isConnected = connections.has(device.id);
                const status = isConnected ? 'âœ… Connected' : 'ðŸ”µ Available';
                const action = isConnected ? 'Connected' : `<button onclick="connectToDevice('${device.id}')">Connect</button>`;
                
                html += `
                    <div style="border: 1px solid #ccc; padding: 10px; margin: 5px;">
                        <strong>${device.id}</strong> ${status}<br>
                        <small>${device.userAgent}</small><br>
                        ${action}
                    </div>
                `;
            });
            
            deviceListDiv.innerHTML = html;
        }

        function startDeviceDiscovery() {
            discoverDevices();
            setInterval(discoverDevices, 2000);
        }

        function refreshDevices() {
            discoverDevices();
        }

        function connectToDevice(deviceId) {
            if (connections.has(deviceId)) return;
            
            console.log('Connecting to:', deviceId);
            const conn = peer.connect(deviceId, {
                reliable: true
            });
            
            setupConnection(conn);
        }

        function setupConnection(conn) {
            connections.set(conn.peer, conn);
            
            conn.on('open', function() {
                console.log('Connection opened with:', conn.peer);
                updateConnectionStatus();
                showFileTransfer();
            });

            conn.on('data', function(data) {
                handleIncomingData(data, conn.peer);
            });

            conn.on('close', function() {
                console.log('Connection closed with:', conn.peer);
                connections.delete(conn.peer);
                updateConnectionStatus();
            });

            conn.on('error', function(err) {
                console.error('Connection error:', err);
                connections.delete(conn.peer);
                updateConnectionStatus();
            });
        }

        function updateConnectionStatus() {
            const connectedDevices = Array.from(connections.keys());
            const statusDiv = document.getElementById('connection-status');
            const infoDiv = document.getElementById('connection-info');
            
            if (connectedDevices.length > 0) {
                statusDiv.style.display = 'block';
                infoDiv.innerHTML = `Connected to: ${connectedDevices.join(', ')}`;
            } else {
                statusDiv.style.display = 'none';
            }
        }

        function showFileTransfer() {
            document.getElementById('file-transfer').style.display = 'block';
        }

        function sendFiles() {
            const fileInput = document.getElementById('file-input');
            const files = Array.from(fileInput.files);
            
            if (files.length === 0) {
                alert('Please select files to send');
                return;
            }

            if (connections.size === 0) {
                alert('No devices connected');
                return;
            }

            isTransferring = true;
            sendFilesToAllConnections(files);
        }

        async function sendFilesToAllConnections(files) {
            for (const file of files) {
                await sendFileToAllConnections(file);
            }
            isTransferring = false;
            document.getElementById('transfer-progress').innerHTML += '<br><strong>All files sent!</strong>';
        }

        async function sendFileToAllConnections(file) {
            const fileId = generateFileId();
            const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
            
            // Send file info to all connections
            const fileInfo = {
                type: 'file-start',
                fileId: fileId,
                name: file.name,
                size: file.size,
                mimeType: file.type,
                totalChunks: totalChunks
            };

            connections.forEach(conn => {
                conn.send(fileInfo);
            });

            transferStartTime = Date.now();
            totalBytes = 0;

            document.getElementById('transfer-progress').innerHTML = 
                `Sending: ${file.name} (${formatBytes(file.size)})<br>Progress: 0%`;

            // Send file chunks
            for (let i = 0; i < totalChunks; i++) {
                const start = i * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE, file.size);
                const chunk = file.slice(start, end);
                
                const arrayBuffer = await chunk.arrayBuffer();
                const chunkData = {
                    type: 'file-chunk',
                    fileId: fileId,
                    chunkIndex: i,
                    data: Array.from(new Uint8Array(arrayBuffer))
                };

                connections.forEach(conn => {
                    conn.send(chunkData);
                });

                totalBytes += arrayBuffer.byteLength;
                const progress = (totalBytes / file.size) * 100;
                const speed = calculateSpeed(totalBytes, transferStartTime);

                document.getElementById('transfer-progress').innerHTML = 
                    `Sending: ${file.name} (${formatBytes(file.size)})<br>Progress: ${progress.toFixed(1)}%`;
                document.getElementById('speed-info').innerHTML = `Speed: ${speed}`;

                // Small delay to prevent overwhelming
                await new Promise(resolve => setTimeout(resolve, 1));
            }

            // Send file end
            connections.forEach(conn => {
                conn.send({
                    type: 'file-end',
                    fileId: fileId
                });
            });
        }

        // File receiving logic
        const receivingFiles = new Map();

        function handleIncomingData(data, fromPeer) {
            if (data.type === 'file-start') {
                startReceivingFile(data, fromPeer);
            } else if (data.type === 'file-chunk') {
                receiveFileChunk(data, fromPeer);
            } else if (data.type === 'file-end') {
                finishReceivingFile(data, fromPeer);
            }
        }

        function startReceivingFile(fileInfo, fromPeer) {
            receivingFiles.set(fileInfo.fileId, {
                ...fileInfo,
                chunks: new Array(fileInfo.totalChunks),
                receivedChunks: 0,
                fromPeer: fromPeer,
                startTime: Date.now(),
                totalBytesReceived: 0
            });

            document.getElementById('transfer-progress').innerHTML = 
                `Receiving: ${fileInfo.name} from ${fromPeer}<br>Progress: 0%`;
        }

        function receiveFileChunk(chunkData, fromPeer) {
            const fileInfo = receivingFiles.get(chunkData.fileId);
            if (!fileInfo) return;

            fileInfo.chunks[chunkData.chunkIndex] = new Uint8Array(chunkData.data);
            fileInfo.receivedChunks++;
            fileInfo.totalBytesReceived += chunkData.data.length;

            const progress = (fileInfo.receivedChunks / fileInfo.totalChunks) * 100;
            const speed = calculateSpeed(fileInfo.totalBytesReceived, fileInfo.startTime);

            document.getElementById('transfer-progress').innerHTML = 
                `Receiving: ${fileInfo.name} from ${fromPeer}<br>Progress: ${progress.toFixed(1)}%`;
            document.getElementById('speed-info').innerHTML = `Speed: ${speed}`;
        }

        function finishReceivingFile(endData, fromPeer) {
            const fileInfo = receivingFiles.get(endData.fileId);
            if (!fileInfo) return;

            // Combine all chunks
            const totalSize = fileInfo.chunks.reduce((sum, chunk) => sum + (chunk ? chunk.length : 0), 0);
            const fileData = new Uint8Array(totalSize);
            let offset = 0;

            for (const chunk of fileInfo.chunks) {
                if (chunk) {
                    fileData.set(chunk, offset);
                    offset += chunk.length;
                }
            }

            const blob = new Blob([fileData], { type: fileInfo.mimeType });
            const url = URL.createObjectURL(blob);

            // Add to received files list
            const fileListDiv = document.getElementById('file-list');
            const fileDiv = document.createElement('div');
            fileDiv.style.border = '1px solid #ccc';
            fileDiv.style.padding = '10px';
            fileDiv.style.margin = '5px';
            fileDiv.innerHTML = `
                <strong>${fileInfo.name}</strong> (${formatBytes(fileInfo.size)})<br>
                From: ${fromPeer}<br>
                <a href="${url}" download="${fileInfo.name}">ðŸ“¥ Download</a>
            `;
            fileListDiv.appendChild(fileDiv);

            receivingFiles.delete(endData.fileId);
            
            document.getElementById('transfer-progress').innerHTML += 
                `<br><strong>${fileInfo.name} received successfully!</strong>`;
        }

        function generateFileId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        function calculateSpeed(bytes, startTime) {
            const elapsed = (Date.now() - startTime) / 1000;
            const speed = bytes / elapsed;
            return formatBytes(speed) + '/s';
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            const devices = getStoredDevices();
            delete devices[myDeviceId];
            localStorage.setItem(DISCOVERY_KEY, JSON.stringify(devices));
        });

        // Start the application
        init();
    </script>
</body>
</html>
