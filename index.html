<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reliable File Transfer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 15px;
        }
        
        .container {
            max-width: 500px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 25px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
        }
        
        .main {
            padding: 25px;
        }
        
        .device-section {
            text-align: center;
            margin-bottom: 25px;
        }
        
        .device-circle {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: #4CAF50;
            margin: 15px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .device-circle:hover {
            transform: scale(1.05);
        }
        
        .device-circle.waiting {
            background: #2196F3;
            animation: pulse 2s infinite;
        }
        
        .device-circle.connected {
            background: #4CAF50;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .connection-code {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: center;
            font-family: monospace;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
            color: #333;
        }
        
        .btn {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-primary {
            background: #2196F3;
            color: white;
        }
        
        .btn-success {
            background: #4CAF50;
            color: white;
        }
        
        .btn-danger {
            background: #f44336;
            color: white;
        }
        
        .btn-download {
            background: #FF9800;
            color: white;
            margin: 10px 0;
        }
        
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .input-field {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
        }
        
        .input-field:focus {
            outline: none;
            border-color: #2196F3;
        }
        
        .file-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            margin: 15px 0;
            transition: all 0.3s ease;
        }
        
        .file-area.drag-over {
            border-color: #2196F3;
            background: rgba(33, 150, 243, 0.1);
        }
        
        .file-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #2196F3;
        }
        
        .file-name {
            font-weight: bold;
            margin-bottom: 5px;
            word-break: break-all;
        }
        
        .file-size {
            color: #666;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .progress-container {
            margin: 10px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: #4CAF50;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .progress-text {
            font-size: 12px;
            color: #666;
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
        }
        
        .chunk-info {
            font-size: 11px;
            color: #999;
            text-align: center;
            margin: 5px 0;
        }
        
        .status-message {
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
        }
        
        .status-success {
            background: #e8f5e8;
            color: #2e7d32;
            border: 1px solid #c8e6c9;
        }
        
        .status-error {
            background: #ffebee;
            color: #c62828;
            border: 1px solid #ffcdd2;
        }
        
        .status-info {
            background: #e3f2fd;
            color: #1976d2;
            border: 1px solid #bbdefb;
        }
        
        .hidden {
            display: none;
        }
        
        .download-item {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #4CAF50;
        }
        
        .reliability-indicator {
            background: #fff3e0;
            color: #ef6c00;
            padding: 8px;
            border-radius: 5px;
            margin: 5px 0;
            font-size: 11px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚ö° High-Speed Transfer</h1>
            <p>Ultra-fast + 100% reliable delivery</p>
        </div>
        
        <div class="main">
            <!-- Device Status -->
            <div class="device-section">
                <div id="status-text">Ready to start</div>
                <div id="device-circle" class="device-circle" onclick="startHost()">
                    <span id="device-text">START</span>
                </div>
                
                <!-- Connection Code -->
                <div id="code-section" class="hidden">
                    <div>Share this code:</div>
                    <div id="connection-code" class="connection-code">------</div>
                </div>
            </div>
            
            <!-- Messages -->
            <div id="messages"></div>
            
            <!-- File Selection -->
            <input type="file" id="file-input" multiple style="display: none;">
            <button class="btn btn-primary" onclick="selectFiles()" id="send-btn" disabled>
                üì§ Select Files to Send
            </button>
            
            <!-- Drag Drop -->
            <div class="file-area" id="drop-area">
                <p>üìé Drop files here or click above</p>
            </div>
            
            <!-- Sending Files -->
            <div id="sending-files"></div>
            
            <!-- Connection -->
            <input type="text" id="peer-code" placeholder="Enter code from other device" class="input-field">
            <button class="btn btn-success" onclick="connectToPeer()" id="connect-btn">
                üîó Connect
            </button>
            
            <!-- Received Files -->
            <div id="received-files"></div>
            
            <!-- Disconnect -->
            <button class="btn btn-danger hidden" onclick="disconnect()" id="disconnect-btn">
                ‚ùå Disconnect
            </button>
        </div>
    </div>

    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script>
        class ReliableFileTransfer {
            constructor() {
                this.peer = null;
                this.connection = null;
                this.connectionCode = '';
                this.isConnected = false;
                
                // File transfer state
                this.sendingFiles = new Map();
                this.receivingFiles = new Map();
                
                // Reliability settings
                this.chunkSize = 128 * 1024; // 128KB chunks for speed
                this.maxRetries = 3;
                this.chunkTimeout = 5000; // 5 seconds per chunk
                this.ackTimeout = 2000; // 2 seconds for acknowledgment
                
                // Speed optimizations
                this.windowSize = 20; // Send 20 chunks in parallel
                this.batchAckSize = 5; // Batch ACKs for efficiency
                this.adaptiveChunking = true;
                
                this.init();
            }
            
            init() {
                this.setupDragDrop();
                this.setupFileInput();
                this.log('Reliable transfer system initialized');
            }
            
            log(message) {
                console.log('[ReliableTransfer]', message);
            }
            
            setupDragDrop() {
                const dropArea = document.getElementById('drop-area');
                
                dropArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropArea.classList.add('drag-over');
                });
                
                dropArea.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    dropArea.classList.remove('drag-over');
                });
                
                dropArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropArea.classList.remove('drag-over');
                    this.handleFiles(e.dataTransfer.files);
                });
            }
            
            setupFileInput() {
                document.getElementById('file-input').addEventListener('change', (e) => {
                    this.handleFiles(e.target.files);
                });
            }
            
            generateCode() {
                return Math.random().toString(36).substring(2, 8).toUpperCase();
            }
            
            async startHost() {
                try {
                    this.connectionCode = this.generateCode();
                    this.showMessage('Starting reliable connection...', 'info');
                    
                    this.peer = new Peer(this.connectionCode, {
                        debug: 0,
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' }
                            ],
                            // High-speed optimizations
                            sdpSemantics: 'unified-plan',
                            bundlePolicy: 'max-bundle',
                            rtcpMuxPolicy: 'require'
                        }
                    });
                    
                    this.peer.on('open', (id) => {
                        this.log(`Host started: ${id}`);
                        this.updateStatus('Waiting for connection...', 'waiting');
                        this.showConnectionCode();
                        this.showMessage('Share the code with other device', 'info');
                    });
                    
                    this.peer.on('connection', (conn) => {
                        this.log('Incoming connection');
                        this.connection = conn;
                        this.setupReliableConnection();
                    });
                    
                    this.peer.on('error', (err) => {
                        this.log(`Peer error: ${err}`);
                        this.showMessage('Connection failed. Try again.', 'error');
                        this.resetConnection();
                    });
                    
                } catch (error) {
                    this.log(`Start error: ${error}`);
                    this.showMessage('Failed to start. Try again.', 'error');
                }
            }
            
            async connectToPeer() {
                const code = document.getElementById('peer-code').value.trim().toUpperCase();
                if (!code) {
                    this.showMessage('Please enter a code', 'error');
                    return;
                }
                
                try {
                    this.showMessage('Connecting...', 'info');
                    
                    this.peer = new Peer({
                        debug: 0,
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' }
                            ],
                            // High-speed optimizations
                            sdpSemantics: 'unified-plan',
                            bundlePolicy: 'max-bundle',
                            rtcpMuxPolicy: 'require'
                        }
                    });
                    
                    this.peer.on('open', () => {
                        this.log('Connecting to peer');
                        this.connection = this.peer.connect(code, {
                            reliable: true,
                            // High-speed data channel optimizations
                            serialization: 'binary',
                            metadata: { highSpeed: true }
                        });
                        this.setupReliableConnection();
                        this.updateStatus('Connecting...', 'waiting');
                    });
                    
                    this.peer.on('error', (err) => {
                        this.log(`Connect error: ${err}`);
                        this.showMessage('Failed to connect. Check code.', 'error');
                        this.resetConnection();
                    });
                    
                } catch (error) {
                    this.log(`Connect error: ${error}`);
                    this.showMessage('Connection failed. Try again.', 'error');
                }
            }
            
            setupReliableConnection() {
                if (!this.connection) return;
                
                this.connection.on('open', () => {
                    this.log('Reliable connection established');
                    this.isConnected = true;
                    this.updateStatus('Connected!', 'connected');
                    this.showMessage('‚úÖ High-speed reliable connection ready!', 'success');
                    this.enableFileSharing();
                });
                
                this.connection.on('data', (data) => {
                    this.handleReliableData(data);
                });
                
                this.connection.on('close', () => {
                    this.log('Connection closed');
                    this.showMessage('Connection closed', 'error');
                    this.resetConnection();
                });
                
                this.connection.on('error', (err) => {
                    this.log(`Connection error: ${err}`);
                    this.showMessage('Connection error', 'error');
                    this.resetConnection();
                });
            }
            
            showConnectionCode() {
                document.getElementById('connection-code').textContent = this.connectionCode;
                document.getElementById('code-section').classList.remove('hidden');
            }
            
            updateStatus(message, state) {
                document.getElementById('status-text').textContent = message;
                const circle = document.getElementById('device-circle');
                const text = document.getElementById('device-text');
                
                circle.className = 'device-circle';
                if (state) circle.classList.add(state);
                
                switch (state) {
                    case 'waiting':
                        text.textContent = 'WAITING';
                        break;
                    case 'connected':
                        text.textContent = 'CONNECTED';
                        break;
                    default:
                        text.textContent = 'START';
                }
            }
            
            enableFileSharing() {
                document.getElementById('send-btn').disabled = false;
                document.getElementById('connect-btn').classList.add('hidden');
                document.getElementById('disconnect-btn').classList.remove('hidden');
            }
            
            handleFiles(files) {
                if (!this.isConnected) {
                    this.showMessage('Please connect first', 'error');
                    return;
                }
                
                Array.from(files).forEach((file, index) => {
                    this.sendFileReliably(file, `file_${Date.now()}_${index}`);
                });
            }
            
            async sendFileReliably(file, fileId) {
                this.log(`Starting high-speed reliable send: ${file.name}`);
                
                const totalChunks = Math.ceil(file.size / this.chunkSize);
                
                // Initialize file transfer state
                const fileState = {
                    file: file,
                    fileId: fileId,
                    totalChunks: totalChunks,
                    sentChunks: 0,
                    ackedChunks: new Set(),
                    retryCount: new Map(),
                    startTime: Date.now(),
                    lastProgressTime: Date.now(),
                    lastProgressChunks: 0,
                    inFlight: new Set(), // Chunks currently being sent
                    nextChunkToSend: 0,
                    pendingAcks: [] // For batching ACKs
                };
                
                this.sendingFiles.set(fileId, fileState);
                this.showSendingFile(fileState);
                
                // Send file metadata
                this.sendReliableData({
                    type: 'file-start',
                    fileId: fileId,
                    name: file.name,
                    size: file.size,
                    totalChunks: totalChunks,
                    chunkSize: this.chunkSize
                });
                
                // Start high-speed parallel sending
                this.startParallelSending(fileId);
            }
            
            async startParallelSending(fileId) {
                const fileState = this.sendingFiles.get(fileId);
                if (!fileState) return;
                
                // Fill the sending window with parallel chunks
                while (fileState.inFlight.size < this.windowSize && fileState.nextChunkToSend < fileState.totalChunks) {
                    const chunkIndex = fileState.nextChunkToSend;
                    
                    // Skip if already ACKed
                    if (fileState.ackedChunks.has(chunkIndex)) {
                        fileState.nextChunkToSend++;
                        continue;
                    }
                    
                    // Skip if too many retries
                    const retries = fileState.retryCount.get(chunkIndex) || 0;
                    if (retries >= this.maxRetries) {
                        fileState.nextChunkToSend++;
                        continue;
                    }
                    
                    // Send chunk
                    fileState.inFlight.add(chunkIndex);
                    fileState.nextChunkToSend++;
                    this.sendChunkAsync(fileId, chunkIndex);
                }
                
                // Check if transfer is complete
                if (fileState.ackedChunks.size === fileState.totalChunks) {
                    this.completeSend(fileId);
                } else if (fileState.inFlight.size === 0 && fileState.nextChunkToSend >= fileState.totalChunks) {
                    // No more chunks to send and nothing in flight - check for failures
                    const failedChunks = [];
                    for (let i = 0; i < fileState.totalChunks; i++) {
                        if (!fileState.ackedChunks.has(i)) {
                            const retries = fileState.retryCount.get(i) || 0;
                            if (retries >= this.maxRetries) {
                                failedChunks.push(i);
                            }
                        }
                    }
                    
                    if (failedChunks.length > 0) {
                        this.showMessage(`Transfer failed: ${fileState.file.name} - ${failedChunks.length} chunks failed`, 'error');
                    }
                }
            }
            
            async sendChunkAsync(fileId, chunkIndex) {
                const fileState = this.sendingFiles.get(fileId);
                if (!fileState) return;
                
                try {
                    // Read chunk
                    const start = chunkIndex * this.chunkSize;
                    const end = Math.min(start + this.chunkSize, fileState.file.size);
                    const chunk = fileState.file.slice(start, end);
                    const arrayBuffer = await chunk.arrayBuffer();
                    
                    // Track retry
                    const retryCount = fileState.retryCount.get(chunkIndex) || 0;
                    fileState.retryCount.set(chunkIndex, retryCount + 1);
                    
                    // Send chunk
                    this.sendReliableData({
                        type: 'file-chunk',
                        fileId: fileId,
                        chunkIndex: chunkIndex,
                        data: arrayBuffer,
                        retryCount: retryCount
                    });
                    
                    this.updateSendProgress(fileId);
                    
                    // Set timeout for this chunk
                    setTimeout(() => {
                        if (!fileState.ackedChunks.has(chunkIndex)) {
                            fileState.inFlight.delete(chunkIndex);
                            this.log(`Chunk ${chunkIndex} timeout, will retry`);
                            this.startParallelSending(fileId); // Continue sending
                        }
                    }, this.ackTimeout);
                    
                } catch (error) {
                    this.log(`Error sending chunk ${chunkIndex}: ${error}`);
                    fileState.inFlight.delete(chunkIndex);
                    setTimeout(() => this.startParallelSending(fileId), 100);
                }
            }
            
            sendReliableData(data) {
                if (this.connection && this.isConnected) {
                    try {
                        this.connection.send(data);
                    } catch (error) {
                        this.log(`Send error: ${error}`);
                    }
                }
            }
            
            handleReliableData(data) {
                switch (data.type) {
                    case 'file-start':
                        this.handleFileStart(data);
                        break;
                    case 'file-chunk':
                        this.handleFileChunk(data);
                        break;
                    case 'chunk-ack':
                        this.handleChunkAck(data);
                        break;
                    case 'batch-ack':
                        this.handleBatchAck(data);
                        break;
                    case 'file-complete':
                        this.handleFileComplete(data);
                        break;
                }
            }
            
            handleFileStart(data) {
                this.log(`Receiving file: ${data.name}`);
                
                const fileState = {
                    name: data.name,
                    size: data.size,
                    fileId: data.fileId,
                    totalChunks: data.totalChunks,
                    chunkSize: data.chunkSize,
                    chunks: new Array(data.totalChunks).fill(null),
                    receivedChunks: new Set(),
                    startTime: Date.now(),
                    lastProgressTime: Date.now(),
                    lastProgressChunks: 0
                };
                
                this.receivingFiles.set(data.fileId, fileState);
                this.showReceivingFile(fileState);
                
                // Send acknowledgment
                this.sendReliableData({
                    type: 'file-start-ack',
                    fileId: data.fileId
                });
            }
            
            handleFileChunk(data) {
                const fileState = this.receivingFiles.get(data.fileId);
                if (!fileState) return;
                
                // Store chunk
                fileState.chunks[data.chunkIndex] = new Uint8Array(data.data);
                fileState.receivedChunks.add(data.chunkIndex);
                
                this.log(`Received chunk ${data.chunkIndex}/${fileState.totalChunks}`);
                
                // Add to batch ACK queue for speed
                fileState.pendingAcks = fileState.pendingAcks || [];
                fileState.pendingAcks.push(data.chunkIndex);
                
                // Send batch ACK when we have enough or timeout
                if (fileState.pendingAcks.length >= this.batchAckSize) {
                    this.sendBatchAck(data.fileId);
                } else {
                    // Set timeout for batch ACK
                    if (!fileState.ackTimer) {
                        fileState.ackTimer = setTimeout(() => {
                            this.sendBatchAck(data.fileId);
                        }, 50); // 50ms batch timeout for speed
                    }
                }
                
                this.updateReceiveProgress(data.fileId);
                
                // Check if file is complete
                if (fileState.receivedChunks.size === fileState.totalChunks) {
                    this.assembleReceivedFile(data.fileId);
                }
            }
            
            sendBatchAck(fileId) {
                const fileState = this.receivingFiles.get(fileId);
                if (!fileState || !fileState.pendingAcks || fileState.pendingAcks.length === 0) return;
                
                // Send batch acknowledgment for speed
                this.sendReliableData({
                    type: 'batch-ack',
                    fileId: fileId,
                    chunkIndexes: fileState.pendingAcks.slice() // Copy array
                });
                
                // Clear pending ACKs
                fileState.pendingAcks = [];
                if (fileState.ackTimer) {
                    clearTimeout(fileState.ackTimer);
                    fileState.ackTimer = null;
                }
            }
            
            handleChunkAck(data) {
                const fileState = this.sendingFiles.get(data.fileId);
                if (!fileState) return;
                
                fileState.ackedChunks.add(data.chunkIndex);
                fileState.inFlight.delete(data.chunkIndex);
                this.log(`Chunk ${data.chunkIndex} acknowledged`);
                
                this.updateSendProgress(data.fileId);
                
                // Continue parallel sending
                this.startParallelSending(data.fileId);
            }
            
            handleBatchAck(data) {
                const fileState = this.sendingFiles.get(data.fileId);
                if (!fileState) return;
                
                // Process batch acknowledgments for speed
                data.chunkIndexes.forEach(chunkIndex => {
                    fileState.ackedChunks.add(chunkIndex);
                    fileState.inFlight.delete(chunkIndex);
                });
                
                this.log(`Batch ACK: ${data.chunkIndexes.length} chunks acknowledged`);
                this.updateSendProgress(data.fileId);
                
                // Continue parallel sending
                this.startParallelSending(data.fileId);
            }
            
            completeSend(fileId) {
                const fileState = this.sendingFiles.get(fileId);
                if (!fileState) return;
                
                const duration = (Date.now() - fileState.startTime) / 1000;
                this.log(`File sent successfully: ${fileState.file.name} in ${duration}s`);
                
                // Update UI
                const fileDiv = document.getElementById(`sending-${fileId}`);
                if (fileDiv) {
                    fileDiv.querySelector('.progress-text').innerHTML = '<span>‚úÖ Sent!</span>';
                    fileDiv.querySelector('.reliability-indicator').textContent = '‚úÖ High-speed reliable delivery confirmed';
                }
                
                this.sendingFiles.delete(fileId);
                this.showMessage(`‚úÖ ${fileState.file.name} sent successfully!`, 'success');
            }
            
            assembleReceivedFile(fileId) {
                const fileState = this.receivingFiles.get(fileId);
                if (!fileState) return;
                
                this.log(`Assembling file: ${fileState.name}`);
                
                try {
                    // Calculate total size
                    let totalSize = 0;
                    fileState.chunks.forEach(chunk => {
                        if (chunk) totalSize += chunk.length;
                    });
                    
                    // Assemble file
                    const assembled = new Uint8Array(totalSize);
                    let offset = 0;
                    
                    fileState.chunks.forEach(chunk => {
                        if (chunk) {
                            assembled.set(chunk, offset);
                            offset += chunk.length;
                        }
                    });
                    
                    // Create blob
                    const blob = new Blob([assembled]);
                    fileState.blob = blob;
                    
                    const duration = (Date.now() - fileState.startTime) / 1000;
                    this.log(`File assembled: ${fileState.name} in ${duration}s`);
                    
                    // Update UI
                    const fileDiv = document.getElementById(`receiving-${fileId}`);
                    fileDiv.className = 'download-item';
                    fileDiv.innerHTML = `
                        <div class="file-name">‚úÖ ${fileState.name}</div>
                        <div class="file-size">${this.formatFileSize(blob.size)}</div>
                        <div class="reliability-indicator">‚úÖ High-speed reliable transfer complete</div>
                        <button class="btn btn-download" onclick="app.downloadFile('${fileId}')">
                            üíæ Download File
                        </button>
                    `;
                    
                    this.showMessage(`‚úÖ ${fileState.name} ready to download!`, 'success');
                    
                } catch (error) {
                    this.log(`Assembly error: ${error}`);
                    this.showMessage(`Error receiving ${fileState.name}`, 'error');
                }
            }
            
            showSendingFile(fileState) {
                const container = document.getElementById('sending-files');
                const fileDiv = document.createElement('div');
                fileDiv.className = 'file-item';
                fileDiv.id = `sending-${fileState.fileId}`;
                fileDiv.innerHTML = `
                    <div class="file-name">${fileState.file.name}</div>
                    <div class="file-size">${this.formatFileSize(fileState.file.size)}</div>
                    <div class="reliability-indicator">‚ö° High-speed parallel transfer (${this.windowSize} chunks)</div>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" id="send-progress-${fileState.fileId}"></div>
                        </div>
                        <div class="progress-text" id="send-text-${fileState.fileId}">
                            <span>Starting...</span>
                        </div>
                        <div class="chunk-info" id="send-chunks-${fileState.fileId}">
                            0/${fileState.totalChunks} chunks confirmed
                        </div>
                    </div>
                `;
                container.appendChild(fileDiv);
            }
            
            showReceivingFile(fileState) {
                const container = document.getElementById('received-files');
                const fileDiv = document.createElement('div');
                fileDiv.className = 'file-item';
                fileDiv.id = `receiving-${fileState.fileId}`;
                fileDiv.innerHTML = `
                    <div class="file-name">üì• ${fileState.name}</div>
                    <div class="file-size">${this.formatFileSize(fileState.size)}</div>
                    <div class="reliability-indicator">‚ö° High-speed receiving with batch ACKs</div>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" id="receive-progress-${fileState.fileId}"></div>
                        </div>
                        <div class="progress-text" id="receive-text-${fileState.fileId}">
                            <span>Receiving...</span>
                        </div>
                        <div class="chunk-info" id="receive-chunks-${fileState.fileId}">
                            0/${fileState.totalChunks} chunks received
                        </div>
                    </div>
                `;
                container.appendChild(fileDiv);
                
                this.showMessage(`üì• Receiving ${fileState.name}...`, 'info');
            }
            
            updateSendProgress(fileId) {
                const fileState = this.sendingFiles.get(fileId);
                if (!fileState) return;
                
                const progress = (fileState.ackedChunks.size / fileState.totalChunks) * 100;
                const progressBar = document.getElementById(`send-progress-${fileId}`);
                const progressText = document.getElementById(`send-text-${fileId}`);
                const chunkInfo = document.getElementById(`send-chunks-${fileId}`);
                
                // Calculate speed
                const now = Date.now();
                const timeDiff = (now - fileState.lastProgressTime) / 1000;
                const chunkDiff = fileState.ackedChunks.size - fileState.lastProgressChunks;
                
                if (timeDiff > 1) { // Update speed every second
                    const chunkSpeed = chunkDiff / timeDiff;
                    const bytesPerSecond = chunkSpeed * this.chunkSize;
                    const mbps = (bytesPerSecond / 1024 / 1024).toFixed(1);
                    
                    fileState.lastProgressTime = now;
                    fileState.lastProgressChunks = fileState.ackedChunks.size;
                    fileState.currentSpeed = mbps;
                }
                
                if (progressBar) progressBar.style.width = `${progress}%`;
                if (progressText) {
                    const speedText = fileState.currentSpeed ? ` - ${fileState.currentSpeed} MB/s` : '';
                    progressText.innerHTML = `<span>${Math.round(progress)}%${speedText}</span>`;
                }
                if (chunkInfo) chunkInfo.textContent = `${fileState.ackedChunks.size}/${fileState.totalChunks} chunks confirmed`;
            }
            
            updateReceiveProgress(fileId) {
                const fileState = this.receivingFiles.get(fileId);
                if (!fileState) return;
                
                const progress = (fileState.receivedChunks.size / fileState.totalChunks) * 100;
                const progressBar = document.getElementById(`receive-progress-${fileId}`);
                const progressText = document.getElementById(`receive-text-${fileId}`);
                const chunkInfo = document.getElementById(`receive-chunks-${fileId}`);
                
                // Calculate receive speed
                const now = Date.now();
                const timeDiff = (now - fileState.lastProgressTime) / 1000;
                const chunkDiff = fileState.receivedChunks.size - fileState.lastProgressChunks;
                
                if (timeDiff > 1) { // Update speed every second
                    const chunkSpeed = chunkDiff / timeDiff;
                    const bytesPerSecond = chunkSpeed * fileState.chunkSize;
                    const mbps = (bytesPerSecond / 1024 / 1024).toFixed(1);
                    
                    fileState.lastProgressTime = now;
                    fileState.lastProgressChunks = fileState.receivedChunks.size;
                    fileState.currentSpeed = mbps;
                }
                
                if (progressBar) progressBar.style.width = `${progress}%`;
                if (progressText) {
                    const speedText = fileState.currentSpeed ? ` - ${fileState.currentSpeed} MB/s` : '';
                    progressText.innerHTML = `<span>${Math.round(progress)}%${speedText}</span>`;
                }
                if (chunkInfo) chunkInfo.textContent = `${fileState.receivedChunks.size}/${fileState.totalChunks} chunks received`;
            }
            
            downloadFile(fileId) {
                const fileState = this.receivingFiles.get(fileId);
                if (!fileState || !fileState.blob) {
                    this.showMessage('File not available', 'error');
                    return;
                }
                
                try {
                    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                    
                    if (isIOS && navigator.share) {
                        const file = new File([fileState.blob], fileState.name);
                        navigator.share({
                            files: [file],
                            title: fileState.name
                        }).then(() => {
                            this.showMessage(`Shared: ${fileState.name}`, 'success');
                        }).catch(err => {
                            this.log(`Share failed: ${err}`);
                            this.regularDownload(fileState.blob, fileState.name);
                        });
                    } else {
                        this.regularDownload(fileState.blob, fileState.name);
                    }
                    
                } catch (error) {
                    this.log(`Download error: ${error}`);
                    this.showMessage('Download failed', 'error');
                }
            }
            
            regularDownload(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.style.display = 'none';
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                setTimeout(() => URL.revokeObjectURL(url), 1000);
                
                this.showMessage(`Downloaded: ${filename}`, 'success');
                this.log(`Download completed: ${filename}`);
            }
            
            disconnect() {
                if (this.connection) this.connection.close();
                if (this.peer) this.peer.destroy();
                this.resetConnection();
                this.showMessage('Disconnected', 'info');
            }
            
            resetConnection() {
                this.peer = null;
                this.connection = null;
                this.isConnected = false;
                this.connectionCode = '';
                this.sendingFiles.clear();
                this.receivingFiles.clear();
                
                this.updateStatus('Ready to start', '');
                document.getElementById('code-section').classList.add('hidden');
                document.getElementById('send-btn').disabled = true;
                document.getElementById('connect-btn').classList.remove('hidden');
                document.getElementById('disconnect-btn').classList.add('hidden');
                document.getElementById('sending-files').innerHTML = '';
                document.getElementById('received-files').innerHTML = '';
            }
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            showMessage(message, type) {
                const container = document.getElementById('messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = `status-message status-${type}`;
                messageDiv.textContent = message;
                
                container.innerHTML = '';
                container.appendChild(messageDiv);
                
                setTimeout(() => {
                    if (container.contains(messageDiv)) {
                        container.removeChild(messageDiv);
                    }
                }, 4000);
            }
        }
        
        // Initialize app
        const app = new ReliableFileTransfer();
        
        // Global functions
        function startHost() {
            const deviceText = document.getElementById('device-text');
            if (deviceText.textContent === 'START') {
                app.startHost();
            }
        }
        
        function selectFiles() {
            document.getElementById('file-input').click();
        }
        
        function connectToPeer() {
            app.connectToPeer();
        }
        
        function disconnect() {
            app.disconnect();
        }
    </script>
</body>
</html>
