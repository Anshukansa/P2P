<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P File Transfer</title>
</head>
<body>
    <div id="app">
        <h1>High-Speed P2P File Transfer</h1>
        
        <div id="setup">
            <button id="createRoom">Create Room (Host)</button>
            <br><br>
            <input type="text" id="roomId" placeholder="Enter Room ID">
            <button id="joinRoom">Join Room</button>
        </div>

        <div id="status" style="display:none;">
            <h3>Status: <span id="connectionStatus">Connecting...</span></h3>
            <p>Room ID: <span id="currentRoomId"></span></p>
            <p>Share this Room ID with other devices</p>
        </div>

        <div id="fileSection" style="display:none;">
            <h3>Send Files</h3>
            <input type="file" id="fileInput" multiple>
            <button id="sendFiles">Send Selected Files</button>
            
            <div id="progress" style="display:none;">
                <p>Sending: <span id="fileName"></span></p>
                <progress id="progressBar" value="0" max="100"></progress>
                <span id="progressText">0%</span>
            </div>
        </div>

        <div id="receivedFiles">
            <h3>Received Files</h3>
            <div id="filesList"></div>
        </div>
    </div>

    <script>
        class P2PFileTransfer {
            constructor() {
                this.localConnection = null;
                this.remoteConnection = null;
                this.dataChannel = null;
                this.isHost = false;
                this.roomId = null;
                this.pendingFiles = [];
                this.receivingFile = null;
                this.receivedChunks = [];
                
                this.setupEventListeners();
                this.setupSignaling();
            }

            setupEventListeners() {
                document.getElementById('createRoom').addEventListener('click', () => this.createRoom());
                document.getElementById('joinRoom').addEventListener('click', () => this.joinRoom());
                document.getElementById('sendFiles').addEventListener('click', () => this.sendFiles());
            }

            setupSignaling() {
                // Using Firebase Realtime Database for signaling (you'll need to replace with your config)
                // For GitHub Pages, you can use any free WebRTC signaling service
                this.signalingUrl = 'wss://ws.postman-echo.com/raw'; // Replace with actual signaling server
            }

            async createRoom() {
                this.isHost = true;
                this.roomId = Math.random().toString(36).substring(2, 8).toUpperCase();
                
                document.getElementById('setup').style.display = 'none';
                document.getElementById('status').style.display = 'block';
                document.getElementById('currentRoomId').textContent = this.roomId;
                document.getElementById('connectionStatus').textContent = 'Waiting for peer...';
                
                await this.setupPeerConnection();
                await this.createOffer();
            }

            async joinRoom() {
                const roomId = document.getElementById('roomId').value.trim().toUpperCase();
                if (!roomId) {
                    alert('Please enter a Room ID');
                    return;
                }
                
                this.roomId = roomId;
                this.isHost = false;
                
                document.getElementById('setup').style.display = 'none';
                document.getElementById('status').style.display = 'block';
                document.getElementById('currentRoomId').textContent = this.roomId;
                document.getElementById('connectionStatus').textContent = 'Connecting...';
                
                await this.setupPeerConnection();
                // In real implementation, fetch offer from signaling server
                // For demo, we'll simulate direct connection
                setTimeout(() => this.simulateConnection(), 1000);
            }

            async setupPeerConnection() {
                const config = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                };

                this.localConnection = new RTCPeerConnection(config);
                
                if (this.isHost) {
                    this.dataChannel = this.localConnection.createDataChannel('files', {
                        ordered: true,
                        maxRetransmits: 3
                    });
                    this.setupDataChannel(this.dataChannel);
                } else {
                    this.localConnection.ondatachannel = (event) => {
                        this.dataChannel = event.channel;
                        this.setupDataChannel(this.dataChannel);
                    };
                }

                this.localConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        // Send candidate to remote peer via signaling
                        console.log('ICE candidate:', event.candidate);
                    }
                };

                this.localConnection.onconnectionstatechange = () => {
                    console.log('Connection state:', this.localConnection.connectionState);
                    if (this.localConnection.connectionState === 'connected') {
                        document.getElementById('connectionStatus').textContent = 'Connected';
                        document.getElementById('fileSection').style.display = 'block';
                    }
                };
            }

            setupDataChannel(channel) {
                channel.binaryType = 'arraybuffer';
                
                channel.onopen = () => {
                    console.log('Data channel opened');
                    document.getElementById('connectionStatus').textContent = 'Connected';
                    document.getElementById('fileSection').style.display = 'block';
                };
                
                channel.onmessage = (event) => {
                    this.handleReceivedData(event.data);
                };
                
                channel.onerror = (error) => {
                    console.error('Data channel error:', error);
                };
            }

            async createOffer() {
                const offer = await this.localConnection.createOffer();
                await this.localConnection.setLocalDescription(offer);
                // Send offer to signaling server
                console.log('Created offer:', offer);
            }

            // Simulate connection for demo (replace with real signaling)
            simulateConnection() {
                document.getElementById('connectionStatus').textContent = 'Connected';
                document.getElementById('fileSection').style.display = 'block';
            }

            async sendFiles() {
                const fileInput = document.getElementById('fileInput');
                const files = Array.from(fileInput.files);
                
                if (files.length === 0) {
                    alert('Please select files to send');
                    return;
                }

                for (const file of files) {
                    await this.sendFile(file);
                }
            }

            async sendFile(file) {
                const chunkSize = 16384; // 16KB chunks for high speed
                const totalChunks = Math.ceil(file.size / chunkSize);
                
                // Send file metadata
                const metadata = {
                    type: 'fileStart',
                    name: file.name,
                    size: file.size,
                    totalChunks: totalChunks,
                    mimeType: file.type
                };
                
                if (this.dataChannel && this.dataChannel.readyState === 'open') {
                    this.dataChannel.send(JSON.stringify(metadata));
                } else {
                    // For demo, simulate sending
                    this.simulateSending(file);
                    return;
                }

                document.getElementById('progress').style.display = 'block';
                document.getElementById('fileName').textContent = file.name;

                // Send file in chunks
                for (let i = 0; i < totalChunks; i++) {
                    const start = i * chunkSize;
                    const end = Math.min(start + chunkSize, file.size);
                    const chunk = file.slice(start, end);
                    
                    const arrayBuffer = await chunk.arrayBuffer();
                    
                    if (this.dataChannel && this.dataChannel.readyState === 'open') {
                        this.dataChannel.send(arrayBuffer);
                    }
                    
                    const progress = ((i + 1) / totalChunks) * 100;
                    document.getElementById('progressBar').value = progress;
                    document.getElementById('progressText').textContent = `${Math.round(progress)}%`;
                    
                    // Small delay to prevent overwhelming
                    if (i % 10 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }

                // Send end marker
                const endMarker = { type: 'fileEnd' };
                if (this.dataChannel && this.dataChannel.readyState === 'open') {
                    this.dataChannel.send(JSON.stringify(endMarker));
                }

                document.getElementById('progress').style.display = 'none';
                alert(`File "${file.name}" sent successfully!`);
            }

            simulateSending(file) {
                document.getElementById('progress').style.display = 'block';
                document.getElementById('fileName').textContent = file.name;
                
                let progress = 0;
                const interval = setInterval(() => {
                    progress += 5;
                    document.getElementById('progressBar').value = progress;
                    document.getElementById('progressText').textContent = `${progress}%`;
                    
                    if (progress >= 100) {
                        clearInterval(interval);
                        document.getElementById('progress').style.display = 'none';
                        this.simulateReceiving(file);
                        alert(`File "${file.name}" sent successfully!`);
                    }
                }, 50);
            }

            simulateReceiving(file) {
                const filesList = document.getElementById('filesList');
                const fileDiv = document.createElement('div');
                fileDiv.innerHTML = `
                    <p><strong>${file.name}</strong> (${this.formatFileSize(file.size)})</p>
                    <button onclick="p2pTransfer.downloadFile('${file.name}', ${file.size}, '${file.type}')">Download</button>
                    <hr>
                `;
                filesList.appendChild(fileDiv);
                
                // Store file data for download
                if (!window.receivedFiles) window.receivedFiles = new Map();
                window.receivedFiles.set(file.name, file);
            }

            handleReceivedData(data) {
                if (typeof data === 'string') {
                    const message = JSON.parse(data);
                    
                    if (message.type === 'fileStart') {
                        this.receivingFile = {
                            name: message.name,
                            size: message.size,
                            totalChunks: message.totalChunks,
                            mimeType: message.mimeType,
                            receivedChunks: 0
                        };
                        this.receivedChunks = [];
                        console.log('Receiving file:', message.name);
                        
                    } else if (message.type === 'fileEnd') {
                        this.finalizeReceivedFile();
                    }
                } else {
                    // Binary data (file chunk)
                    if (this.receivingFile) {
                        this.receivedChunks.push(new Uint8Array(data));
                        this.receivingFile.receivedChunks++;
                        
                        const progress = (this.receivingFile.receivedChunks / this.receivingFile.totalChunks) * 100;
                        console.log(`Receiving ${this.receivingFile.name}: ${Math.round(progress)}%`);
                    }
                }
            }

            finalizeReceivedFile() {
                if (!this.receivingFile) return;
                
                // Combine chunks
                const totalSize = this.receivedChunks.reduce((size, chunk) => size + chunk.length, 0);
                const combinedArray = new Uint8Array(totalSize);
                let offset = 0;
                
                for (const chunk of this.receivedChunks) {
                    combinedArray.set(chunk, offset);
                    offset += chunk.length;
                }
                
                // Create blob and add to received files
                const blob = new Blob([combinedArray], { type: this.receivingFile.mimeType });
                const file = new File([blob], this.receivingFile.name, { type: this.receivingFile.mimeType });
                
                this.addReceivedFile(file);
                
                // Reset
                this.receivingFile = null;
                this.receivedChunks = [];
            }

            addReceivedFile(file) {
                const filesList = document.getElementById('filesList');
                const fileDiv = document.createElement('div');
                fileDiv.innerHTML = `
                    <p><strong>${file.name}</strong> (${this.formatFileSize(file.size)})</p>
                    <button onclick="p2pTransfer.downloadFile('${file.name}', ${file.size}, '${file.type}')">Download</button>
                    <hr>
                `;
                filesList.appendChild(fileDiv);
                
                // Store file for download
                if (!window.receivedFiles) window.receivedFiles = new Map();
                window.receivedFiles.set(file.name, file);
            }

            downloadFile(fileName, fileSize, fileType) {
                const file = window.receivedFiles?.get(fileName);
                if (!file) {
                    alert('File not found');
                    return;
                }
                
                const url = URL.createObjectURL(file);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
        }

        // Initialize
        const p2pTransfer = new P2PFileTransfer();
        window.p2pTransfer = p2pTransfer; // Make global for button clicks
        
        // Initialize received files storage
        window.receivedFiles = new Map();
    </script>
</body>
</html>
